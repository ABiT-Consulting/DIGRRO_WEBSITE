name: Deploy to cPanel

on:
  push:
    branches:
      - main
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  build_deploy_branch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Build site
        shell: bash
        run: |
          set -euo pipefail
          npm ci
          npm run build

      - name: Publish dist to cpanel-deploy branch
        shell: bash
        env:
          DEPLOY_BRANCH: cpanel-deploy
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          if [[ ! -d dist ]]; then
            echo "::error::dist directory not found after build."
            exit 1
          fi

          repo_url="https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          publish_dir="$(mktemp -d)"

          if git ls-remote --exit-code --heads "$repo_url" "${DEPLOY_BRANCH}" >/dev/null 2>&1; then
            git clone --depth 1 --branch "${DEPLOY_BRANCH}" "$repo_url" "$publish_dir"
          else
            git clone --depth 1 "$repo_url" "$publish_dir"
            pushd "$publish_dir" >/dev/null
            git checkout --orphan "${DEPLOY_BRANCH}"
            git rm -rf . >/dev/null 2>&1 || true
            popd >/dev/null
          fi

          find "$publish_dir" -mindepth 1 -maxdepth 1 ! -name .git -exec rm -rf {} +

          /bin/cp .cpanel.yml "${publish_dir}/.cpanel.yml"
          /bin/mkdir -p "${publish_dir}/dist"
          /bin/cp -a ./dist/. "${publish_dir}/dist/"

          pushd "${publish_dir}" >/dev/null
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add -A

          if git diff --cached --quiet; then
            echo "No deployment changes to commit on ${DEPLOY_BRANCH}."
          else
            git commit -m "Deploy ${GITHUB_SHA}"
            git push origin "${DEPLOY_BRANCH}"
          fi
          popd >/dev/null

  deploy:
    needs: build_deploy_branch
    runs-on: ubuntu-latest
    steps:
      - name: Trigger cPanel deployment and wait
        shell: bash
        env:
          CPANEL_HOST: ${{ secrets.CPANEL_HOST }}
          CPANEL_PORT: ${{ secrets.CPANEL_PORT }}
          CPANEL_USER: ${{ secrets.CPANEL_USER }}
          CPANEL_TOKEN: ${{ secrets.CPANEL_TOKEN }}
          CPANEL_REPO_ROOT: ${{ secrets.CPANEL_REPO_ROOT }}
          CPANEL_REPO_ROOT_FALLBACK: ${{ secrets.CPANEL_REPO_ROOT_FALLBACK }}
          CPANEL_BRANCH: cpanel-deploy
          CPANEL_INSECURE: ${{ secrets.CPANEL_INSECURE }}
        run: |
          set -euo pipefail

          : "${CPANEL_HOST:?Missing secret CPANEL_HOST (example: server.example.com)}"
          : "${CPANEL_USER:?Missing secret CPANEL_USER (your cPanel username)}"
          : "${CPANEL_TOKEN:?Missing secret CPANEL_TOKEN (cPanel API token)}"
          : "${CPANEL_REPO_ROOT:?Missing secret CPANEL_REPO_ROOT (absolute path to the cPanel git repo)}"

          port="${CPANEL_PORT:-2083}"
          branch="${CPANEL_BRANCH:-cpanel-deploy}"
          base="https://${CPANEL_HOST}:${port}"
          active_repo_root="${CPANEL_REPO_ROOT}"
          fallback_repo_root="${CPANEL_REPO_ROOT_FALLBACK:-${CPANEL_REPO_ROOT}_auto}"

          auth_header="Authorization: cpanel ${CPANEL_USER}:${CPANEL_TOKEN}"
          curl_flags=(-sS)
          if [[ "${CPANEL_INSECURE:-}" == "true" ]]; then
            curl_flags+=(-k)
          fi

          if ! command -v jq >/dev/null 2>&1; then
            echo "::error::jq is required but not found on the runner."
            exit 1
          fi

          cpanel_get() {
            local endpoint="$1"; shift
            local out="$1"; shift
            local url="${base}/execute/${endpoint}"
            local err
            err="$(mktemp)"

            local cmd=(curl "${curl_flags[@]}" -H "$auth_header" -H "Accept: application/json" --get)
            local kv
            for kv in "$@"; do
              cmd+=(--data-urlencode "$kv")
            done
            cmd+=("$url" -o "$out" -w "%{http_code}")

            set +e
            local code
            code="$("${cmd[@]}" 2>"$err")"
            local rc=$?
            set -e

            if (( rc != 0 )); then
              echo "::error::curl failed for ${endpoint} (rc=${rc})"
              sed -n '1,200p' "$err" || true
              if [[ -s "$out" ]]; then
                echo "---- response ----"
                sed -n '1,200p' "$out" || true
                echo "---- end ----"
              fi
              return 1
            fi

            if [[ "$code" =~ ^[0-9]+$ ]] && (( code >= 400 )); then
              echo "::error::HTTP ${code} from ${endpoint}"
              if [[ -s "$out" ]]; then
                echo "---- response ----"
                sed -n '1,200p' "$out" || true
                echo "---- end ----"
              fi
              return 1
            fi

            return 0
          }

          jq_ok_or_dump() {
            local file="$1"
            if ! jq . "$file" >/dev/null 2>&1; then
              echo "::error::Response was not valid JSON."
              sed -n '1,200p' "$file" || true
              return 1
            fi
            return 0
          }

          jq_status_or_error() {
            local file="$1"
            local endpoint="$2"
            if ! jq -e '((.result // .).status // 0) == 1' "$file" >/dev/null 2>&1; then
              echo "::error::${endpoint} returned status != 1"

              raw="$(jq -c '.' "$file" 2>/dev/null || true)"
              if [[ -n "${raw:-}" && "${raw:-null}" != "null" ]]; then
                raw="${raw:0:1500}"
                echo "::error::Response(excerpt): ${raw}"
              fi

              meta="$(jq -c '(.result // .).metadata // {}' "$file" 2>/dev/null || true)"
              if [[ -n "${meta:-}" && "${meta:-null}" != "null" && "${meta:-}" != "{}" ]]; then
                echo "::error::Metadata: ${meta}"
              fi

              reason="$(jq -r '(.result // .).metadata.reason // empty' "$file" 2>/dev/null || true)"
              if [[ -n "${reason:-}" && "${reason:-null}" != "null" ]]; then
                echo "::error::Reason: ${reason}"
              fi

              errors_json="$(jq -c '(.result // .).errors // empty' "$file" 2>/dev/null || true)"
              if [[ -n "${errors_json:-}" && "${errors_json:-null}" != "null" && "${errors_json:-}" != "[]" ]]; then
                echo "::error::Errors: ${errors_json}"
              fi

              messages_json="$(jq -c '(.result // .).messages // empty' "$file" 2>/dev/null || true)"
              if [[ -n "${messages_json:-}" && "${messages_json:-null}" != "null" && "${messages_json:-}" != "[]" ]]; then
                echo "::error::Messages: ${messages_json}"
              fi
              return 1
            fi
            return 0
          }

          cpanel_update_repo() {
            local repo_root="$1"
            local out="$2"
            echo "Updating cPanel repo (branch=${branch}): ${repo_root}"
            cpanel_get "VersionControl/update" "$out" \
              "repository_root=${repo_root}" \
              "branch=${branch}"
            jq_ok_or_dump "$out"
            jq . "$out"
          }

          cpanel_create_repo() {
            local repo_root="$1"
            local out="$2"
            local repo_name
            repo_name="$(basename "$repo_root")"
            local source_repo_json
            source_repo_json="$(jq -cn --arg url "https://github.com/${GITHUB_REPOSITORY}.git" '{remote_name:"origin",url:$url}')"

            cpanel_get "VersionControl/create" "$out" \
              "name=${repo_name}" \
              "repository_root=${repo_root}" \
              "type=git" \
              "source_repository=${source_repo_json}"
            jq_ok_or_dump "$out"
            jq . "$out"
          }

          update_resp="$(mktemp)"
          cpanel_update_repo "$active_repo_root" "$update_resp"
          if ! jq_status_or_error "$update_resp" "VersionControl/update"; then
            update_errors="$(jq -r '((.result // .).errors // []) | join(" | ")' "$update_resp" 2>/dev/null || true)"
            if [[ "${update_errors}" == *"Not possible to fast-forward"* || "${update_errors}" == *"Diverging branches"* ]]; then
              echo "cPanel repo diverged. Attempting one-time auto-recreate: ${active_repo_root}"

              delete_resp="$(mktemp)"
              cpanel_get "VersionControl/delete" "$delete_resp" \
                "repository_root=${active_repo_root}"
              jq_ok_or_dump "$delete_resp"
              jq . "$delete_resp"
              jq_status_or_error "$delete_resp" "VersionControl/delete" || true

              create_repo_resp="$(mktemp)"
              cpanel_create_repo "$active_repo_root" "$create_repo_resp" || true

              if ! jq_status_or_error "$create_repo_resp" "VersionControl/create"; then
                create_errors="$(jq -r '((.result // .).errors // []) | join(" | ")' "$create_repo_resp" 2>/dev/null || true)"
                if [[ "${create_errors}" == *"already contains files"* && "${fallback_repo_root}" != "${active_repo_root}" ]]; then
                  echo "Primary repo path still has files. Using fallback repo path: ${fallback_repo_root}"
                  active_repo_root="${fallback_repo_root}"

                  create_repo_resp="$(mktemp)"
                  cpanel_create_repo "$active_repo_root" "$create_repo_resp" || true
                  if ! jq_status_or_error "$create_repo_resp" "VersionControl/create"; then
                    echo "Fallback create did not succeed; trying update on fallback in case repo already exists."
                  fi
                else
                  exit 1
                fi
              fi

              update_resp="$(mktemp)"
              cpanel_update_repo "$active_repo_root" "$update_resp"
              jq_status_or_error "$update_resp" "VersionControl/update"
            else
              exit 1
            fi
          fi

          deployable="$(jq -r '(.result // .).data.deployable // 0' "$update_resp")"
          deployable_reason="$(jq -r '(.result // .).data.deployable_reason // empty' "$update_resp")"
          if [[ "$deployable" != "1" ]]; then
            echo "::error::Repository is not deployable. ${deployable_reason}"
            exit 1
          fi

          echo "Triggering cPanel deploy for repo: ${active_repo_root}"
          create_resp="$(mktemp)"
          cpanel_get "VersionControlDeployment/create" "$create_resp" \
            "repository_root=${active_repo_root}"
          jq_ok_or_dump "$create_resp"
          jq . "$create_resp"
          jq_status_or_error "$create_resp" "VersionControlDeployment/create"

          deploy_id="$(jq -r '(.result // .).data.deploy_id // empty' "$create_resp")"
          log_path="$(jq -r '(.result // .).data.log_path // empty' "$create_resp")"
          if [[ -z "$deploy_id" || "$deploy_id" == "null" ]]; then
            echo "Missing deploy_id in response."
            exit 1
          fi

          echo "Deployment queued: deploy_id=${deploy_id}"
          echo "Deployment log path: ${log_path}"

          deadline=$((SECONDS + 300))
          while true; do
            retrieve_resp="$(mktemp)"
            cpanel_get "VersionControlDeployment/retrieve" "$retrieve_resp"
            jq_ok_or_dump "$retrieve_resp"
            jq_status_or_error "$retrieve_resp" "VersionControlDeployment/retrieve" || true

            entry="$(jq -c --arg id "$deploy_id" '((.result // .).data[]? | select((.deploy_id|tostring) == $id) | .) // empty' "$retrieve_resp" | head -n1 || true)"
            if [[ -z "$entry" ]]; then
              echo "Waiting for deploy_id=${deploy_id} to appear..."
            else
              echo "$entry" | jq .

              succeeded="$(echo "$entry" | jq -r '.timestamps.succeeded // empty')"
              failed="$(echo "$entry" | jq -r '.timestamps.failed // empty')"
              canceled="$(echo "$entry" | jq -r '.timestamps.canceled // empty')"

              if [[ -n "$succeeded" ]]; then
                ident="$(echo "$entry" | jq -r '.repository_state.identifier // empty')"
                branch="$(echo "$entry" | jq -r '.repository_state.branch // empty')"
                echo "cPanel deploy: success (branch=${branch}, commit=${ident})"
                exit 0
              fi

              if [[ -n "$failed" || -n "$canceled" ]]; then
                echo "cPanel deploy: failed (deploy_id=${deploy_id})"
                echo "Deployment log path: ${log_path}"

                if [[ -n "$log_path" && "$log_path" != "null" ]]; then
                  log_dir="$(dirname "$log_path")"
                  log_file="$(basename "$log_path")"

                  log_resp="$(mktemp)"
                  cpanel_get "Fileman/get_file_content" "$log_resp" \
                    "dir=${log_dir}" \
                    "file=${log_file}" \
                    "to_charset=utf-8" || true

                  echo "---- cPanel deploy log (tail) ----"
                  jq -r '(.result // .).data.content // empty' "$log_resp" | tail -n 200 || true
                  echo "---- end ----"
                fi

                exit 1
              fi
            fi

            if (( SECONDS >= deadline )); then
              echo "Timed out waiting for cPanel deployment to complete (deploy_id=${deploy_id})."
              echo "Deployment log path: ${log_path}"
              exit 1
            fi

            sleep 3
          done
